import std;
import mem;

public type List<T> = struct {
    data: std.slice.Slice.<T>,
    capacity: usize
};

public fun newWithCapacity<T>(capacity: usize) -> List.<T> {
    return <(List.<T>)> {
        data: std.slice.new.<T>(mem.allocate(T.sizeof * capacity) as *T, 0),
        capacity: capacity,
    };
}

public fun newFromSlice<T>(slice: std.slice.Slice.<T>) -> List.<T> {
    var result = newWithCapacity.<T>(slice.length);
    result.appendSlice(slice);
    return result;
}

public fun List.appendSlice(&self, slice: std.slice.Slice.<T>) {
    self.reserve(self.*.data.length + slice.length);

    var i: usize = 0;
    while i < slice.length {
        self.push(slice.raw[i]);
        i += 1;
    }
}

public fun List.reserve(&self, capacity: usize) {
    if self.*.capacity >= capacity {
        return;
    }
    self.*.data.raw = mem.reallocate(self.*.data.raw as *void, capacity) as *T;
    self.*.capacity = capacity;
}

public fun List.push(&self, value: T) {
    if self.*.data.length + 1 > self.*.capacity {
        var newCapacity = self.*.data.length * 2;
        if newCapacity < self.*.data.length + 1 {
            newCapacity = self.*.data.length + 1;
        }
        self.reserve(newCapacity);
    }
    self.*.data.raw[self.*.data.length] = value;
    self.*.data.length += 1;
}

public fun List.free(self) {
    mem.free(self.data.raw as *void);
}

